#version 450 core

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

layout(rgba32f, binding = 0) uniform image2D imgOutput;
layout(binding = 1) uniform sampler2D uDiff;
layout(binding = 2) uniform sampler2D uRough;
layout(binding = 3) uniform sampler2D uNorm;

layout(location = 0) uniform float uTime;
layout(location = 1) uniform ivec2 uRes;
layout(location = 2) uniform mat3 uCamMat;
layout(location = 3) uniform vec3 uCamPos;
layout(location = 4) uniform float uFOV;
layout(location = 5) uniform float uMaxBounce;
layout(location = 6) uniform float uRayPerPixel;

struct Sphere {
    vec4 origin;
    vec4 color;
    vec4 info;
};

layout(std430, binding = 1) buffer ssbo {
    Sphere objects[];
};

struct Ray {
    vec3 origin;
    vec3 dir;
};

struct HitInfo {
    bool didHit;
    float dst;
    vec3 hitPoint;
    vec3 center;
    vec3 normal;
    vec4 color;
    vec4 info;
};

float RandomValue(inout uint state) {
    state = state * 747796405 + 2891336453;
    uint result = ((state >> ((state >> 28) + 4)) ^ state) * 277803737;
    result = (result >> 22) ^ result;
    return result / 4294967295.0;
}

float RandomValueNormalDistribution(inout uint state) {
    float theta = 2 * 3.1415926 * RandomValue(state);
    float rho = sqrt(-2 * log(RandomValue(state)));
    return rho * cos(theta);
}

vec3 RandomDirection(inout uint state) {
    float x = RandomValueNormalDistribution(state);
    float y = RandomValueNormalDistribution(state);
    float z = RandomValueNormalDistribution(state);
    return normalize(vec3(x, y, z));
}

vec3 RandomHemisphereDirection(vec3 normal, inout uint rngState) {
    vec3 dir = RandomDirection(rngState);
    return dir * sign(dot(normal, dir));
}

vec2 RandomPointInCircle(inout uint rngState) {
    float angle = RandomValue(rngState) * 2 * 3.1415926;
    vec2 pointOnCircle = vec2(cos(angle), sin(angle));
    return pointOnCircle * sqrt(RandomValue(rngState));
}

vec2 getSphereUV(vec3 hitPoint, vec3 sphereCenter) {
    vec3 localP = hitPoint - sphereCenter;
    // Normalize the local point to ensure it's on the sphere surface
    vec3 n = normalize(localP);

    // Calculate spherical coordinates
    float u = 0.5 + atan(n.z, n.x) / (2.0 * 3.14159);
    float v = 0.5 - asin(n.y) / 3.14159;

    return vec2(u, v);
}

vec3 applyNormalMap(vec3 norm, vec2 uv) {
    // Sample the normal map and decode it to tangent space
    vec3 normalMapColor = texture(uNorm, uv).rgb;
    vec3 tangentNormal = normalize(normalMapColor * 2.0 - 1.0);

    // Calculate the TBN matrix
    // vec3 norm = normalize(norm); // Object-space normal
    vec3 tangent = normalize(vec3(-norm.z, 0.0, norm.x)); // Tangent vector
    vec3 bitangent = cross(norm, tangent); // Bitangent vector

    // Transform tangent-space normal to object/world space
    mat3 TBN = mat3(-tangent, -bitangent, norm);
    vec3 perturbedNormal = normalize(TBN * tangentNormal);

    return perturbedNormal;
}

HitInfo RaySphere(Ray ray, vec3 sphereCenter, float sphereRadius) {
    HitInfo hitInfo;
    hitInfo.didHit = false;
    vec3 offsetRayOrigin = ray.origin - sphereCenter;

    float a = dot(ray.dir, ray.dir);
    float b = 2 * dot(offsetRayOrigin, ray.dir);
    float c = dot(offsetRayOrigin, offsetRayOrigin) - sphereRadius * sphereRadius;

    float discriminant = b * b - 4 * a * c;

    if (discriminant >= 0) {
        float dst = (-b - sqrt(discriminant)) / (2 * a);

        if (dst >= 0) {
            hitInfo.didHit = true;
            hitInfo.dst = dst;
            hitInfo.hitPoint = ray.origin + ray.dir * dst;
            hitInfo.normal = normalize(hitInfo.hitPoint - sphereCenter);
        }
    }
    return hitInfo;
}

HitInfo CalculateRayCollision(Ray ray) {
    HitInfo closestHit;
    closestHit.color = vec4(0.0);
    closestHit.dst = 1000.0;

    for (int i = 0; i < objects.length(); i++) {
        // Intersect ray with a sphere
        Sphere sphere = objects[i];
        HitInfo info = RaySphere(ray, sphere.origin.xyz, sphere.info.x);

        // Output the result
        if (info.didHit && info.dst < closestHit.dst) {
            closestHit = info;
            closestHit.color = sphere.color;
            closestHit.info = sphere.info;
            closestHit.center = sphere.origin.xyz;
        }
    }

    return closestHit;
}

vec3 Trace(Ray ray, inout uint rngState) {
    vec3 incommingLight = vec3(0);
    vec3 rayColor = vec3(1);

    for (int i = 0; i < uMaxBounce; i++) {
        HitInfo info = CalculateRayCollision(ray);
        if (info.didHit) {
            ray.origin = info.hitPoint;
            vec2 sphereUV = getSphereUV(info.hitPoint, info.center);
            vec3 norm = info.info.z == 2.0 ? applyNormalMap(info.normal, sphereUV) : info.normal;

            vec3 diff = normalize(norm + RandomDirection(rngState));
            vec3 spec = reflect(ray.dir, norm);
            float rough = info.info.z == 2.0 ? 1 - texture(uRough, sphereUV).r : info.info.z;
            ray.dir = mix(diff, spec, rough);

            vec3 emittedLight = info.color.xyz * info.info.y;
            incommingLight += emittedLight * rayColor;
            rayColor *= info.info.z == 2.0 ? texture(uDiff, sphereUV).rgb : info.color.rgb;
        } else {
            break;
        }
    }

    return incommingLight;
}

vec4 Render(ivec2 texelCoord) {
    vec2 uv = (vec2(texelCoord) + 0.5) / vec2(uRes) * 2.0 - 1.0;

    float aspectRatio = float(uRes.x) / float(uRes.y);
    uv.x *= aspectRatio;

    float scale = tan(radians(uFOV) * 0.5);

    uint pixelIndex = texelCoord.y * uRes.x + texelCoord.x;
    uint rngState = pixelIndex + uint(uTime) * 719393;

    vec3 totalIncomingLight = vec3(0);

    for (int i = 0; i < uRayPerPixel; i++) {
        Ray ray;
        ray.origin = uCamPos;

        vec2 jitter = RandomPointInCircle(rngState) * 2;
        vec2 jitteredUV = uv + jitter / vec2(uRes);
        vec3 jitteredDir = normalize(uCamMat * vec3(jitteredUV * scale, -1.0));

        ray.dir = jitteredDir;

        totalIncomingLight += Trace(ray, rngState);
    }

    vec3 pixelCol = totalIncomingLight / uRayPerPixel;

    return vec4(pixelCol, 1.0);
}

void main() {
    ivec2 texelCoord = ivec2(gl_GlobalInvocationID.xy);

    vec4 result = Render(texelCoord);
    result = vec4(pow(result.xyz, vec3(0.4545)), 1.0);

    imageStore(imgOutput, texelCoord, result);
}
